import enum

from sqlalchemy import and_, Column, func, Integer, or_  # , String  #  , Enum
from sqlalchemy import event, ForeignKey
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import aliased, reconstructor, relationship
from sqlalchemy.orm.exc import NoResultFound  # , MultipleResultsFound
from sqlalchemy.orm.session import Session

from . import Base
from .entry import Entry
from .draw import Draw, DrawType
# from .player import Player


class Winner(enum.Enum):
    none = 0
    team1 = 1
    team2 = 2


class Match(Base):
    __tablename__ = 'PlayerMatch'

    @reconstructor
    def init_on_load(self):
        self._entry1_id = None  # TODO regarder s'il ne serait pas possible de mettre TOUS ces paramètres à False par défaut
        self._previous_team_id = False  # False by default as it could become None as a query result
        self._previous_match_ids = None
        self._next_match_id = False  # False by default as it could become None as a query result
        self._index_team = None
        self._index_match = None

    id = Column(Integer, primary_key=True)
    # event  # useful? could be reached through draw_id.event isn't it?
    draw = Column(Integer, ForeignKey('Draw.id'))
    draw_id = relationship('Draw', back_populates='match_ids')
    entry = Column(Integer, ForeignKey('Entry.id'))
    entry_id = relationship('Entry', back_populates='match_ids')

    winner = Column(Integer, default=0)  # Column(Enum(Winner))
    # link
    # court
    # court = Column(Integer, ForeignKey('Court.id'))
    # court_id = relationship('Court', back_populates='match_ids')
    # # court.py: match_ids = relationship('Match', back_populates='court_id')
    # plandate Date/Heure
    # locatioh  # useful? could be reached through court.location isn't it?
    planning = Column(Integer)
    van1 = Column(Integer, default=0)
    van2 = Column(Integer, default=0)
    wn = Column(Integer, default=0)
    team1set1 = Column(Integer, default=0)
    team2set1 = Column(Integer, default=0)
    team1set2 = Column(Integer, default=0)
    team2set2 = Column(Integer, default=0)
    team1set3 = Column(Integer, default=0)
    team2set3 = Column(Integer, default=0)
    # name = Column(String(50))
    # player_ids = relationship('Player', back_populates='club_id')

    # @property
    # def session(self):
    #     return Session.object_session(self)

    @hybrid_property
    def index_team(self):
        if self._index_team is None:
            print(f'  COMPUTING index_team for {self}')
            # WORKING for type==elimination
            # if self.draw_id.drawtype == DrawType.ELIMINATION.value:
            #     # if self.previous_team_id is None:  # was not working when a team was "bye" at 1st round
            #     if not self.is_played:
            #         self._index_team = 0
            #     else:
            #         self._index_team = self.previous_team_id.index_team + 1
            # elif self.draw_id.drawtype == DrawType.ROUND_ROBIN.value:
            #     self._index_team = -1  # TODO
            # else:
            #     raise NotImplementedError(f'{self}: unknown drawtype value ({self.draw_id.drawtype})')

----- 2 -----
            # if self.draw_id.drawtype == DrawType.ELIMINATION.value:
            if self.previous_team_id is None:
                self._index_team = 0
            else:
                self._index_team = self.previous_team_id.index_team
                if self.is_played:
                    self._index_team += 1

            if self.draw_id.drawtype == DrawType.ROUND_ROBIN.value:
                if self.entry: #self.is_master:  # signifie que c'est l'en-tête de colonne dans les poules (en gros le type=RR et self.entry est Truthy)  # dans ce cas, endex_team représente l'index de l'équipe APRES avoir fait les matchs de poule, prêt pour l'éventuel tour suivant
                    self._index_team += len(m for m in self.slave_match_ids if m.is_played)  # TODO existe-il une fct comme "filtered"?
                else:#elif self.is_slave:  # signifie que c'est un match de poules: dans ce cas, index_team doit etre la somme des 2 index à la fin du tour précédent (très rare; la plupart du temps ces 2 index vaudront 0)
                    _index = 0
                    if self.my_team_id.previous_team_id is not None:  # INFO: my_team_id n'existe que pour des poules, lorsque self est réellement un match
                        _index += self.my_team_id.previous_team_id.index_team
                    if self.your_team_id.previous_team_id is not None:
                        _index += self.your_team_id.previous_team_id.index_team
                    self._index_team = _index

TODO
define m2o fields: (should only exist for RR matches w/o entry)
    my_team_id
    your_team_id
define field:
    slave_match_ids

-------------
        return self._index_team

    @hybrid_property
    def index_match(self):
        if self._index_match is None:
            print(f'  COMPUTING index_match for {self}')
            if self.draw_id.drawtype == DrawType.ELIMINATION.value:
                # TODO Reactivate me and test me
                # if not self.is_played:
                #     self._index_match = False
                # else:
                self._index_match = sum(m.index_team for m in self.previous_match_ids)
            elif self.draw_id.drawtype == DrawType.ROUND_ROBIN.value:
                # self._index_match = -1  # TODO
----- 3 -----
if self.entry: self._index_match = False  # TODO Check that 'False' est approprié
else:  # "vrai" match de poule
    2020-01-26 Cela doit change je pense: self._index_match = self._index_team  # car pour les "vrais" matchs de poule, on a déjà sommé les indices des 2 équipes
-------------
            else:
                raise NotImplementedError(f'{self}: unknown drawtype value ({self.draw_id.drawtype})')
        return self._index_match

    @hybrid_property
    def previous_team_id(self):
        # if self.id == 15:#pdb 30:
        #     import ipdb; i.set_trace()
        if self._previous_team_id == False:
            print(f'  COMPUTING previous_team_id for {self}')
            if self.draw_id.drawtype == DrawType.ELIMINATION.value:
                match_ = aliased(Match)
                try:
                    self._previous_team_id = (
                        self.session.query(match_)
                        .select_from(Match)
                        .filter_by(id=self.id)
                        .join(match_, and_(Match.entry == match_.entry,
                                           Match.planning == match_.wn))
                        .one_or_none()
                    )
                except:  # TODO Delete me once tests are ok
                    import ipdb; ipdb.set_trace()
                    test = (
                        self.session.query(match_)
                        .select_from(Match)
                        .filter_by(id=self.id)
                        .join(match_, and_(Match.draw == match_.draw,
                                           Match.planning == match_.wn))
                        .all()
                    )
            # elif self.draw_id.drawtype == DrawType.ROUND_ROBIN.value:
            #     self._previous_team_id = None  # TODO
----- 1 -----
            if self.draw_id.drawtype == DrawType.ROUND_ROBIN.value or self._previous_team_id is None:  # if RR or elimination with no previous_team found (could be from an existing previous round)
if self.link and self.entry
    self._previous_team_id = query(Match).filter(and_(draw == self.link.src_draw, entry == self.entry)).orderby (roundnr desc)."first or none"()
else:
    self._previous_team_id = None
-------------
            else:
                raise NotImplementedError(f'{self}: unknown drawtype value ({self.draw_id.drawtype})')
        return self._previous_team_id

    @hybrid_property
    def previous_match_ids(self):
        if self._previous_match_ids is None:
            print(f'  COMPUTING previous_match_ids for {self}')
            if self.draw_id.drawtype == DrawType.ELIMINATION.value:
                match_ = aliased(Match)
                self._previous_match_ids = (
                    self.session.query(match_)
                    .select_from(Match)
                    .filter(and_(Match.id == self.id, Match.is_played))
                    .join(match_, and_(Match.draw == match_.draw,
                        or_(Match.van1 == match_.planning,
                            Match.van2 == match_.planning)))
                    .all()
                )
                # if self.id == 15:  #if len(self._previous_match_ids) == 1:
                #     import ipdb; ipdb.set_trace()
            elif self.draw_id.drawtype == DrawType.ROUND_ROBIN.value:
                # self._previous_match_ids = []  # TODO
----- 4 -----
self._previous_match_ids = []  # pas de previous matchs dans les poules car l'ordre n'a pas de sens
-------------
            else:
                raise NotImplementedError(f'{self}: unknown drawtype value ({self.draw_id.drawtype})')
        return self._previous_match_ids

    @hybrid_property
    def next_match_id(self):
        # TODO Delete if not used
        if self._next_match_id == False:
            print(f'  COMPUTING next_match_id for {self}')
            if self.draw_id.drawtype == DrawType.ELIMINATION.value:
                match_ = aliased(Match)
                self._next_match_id = (
                    self.session.query(match_)
                    .select_from(Match)
                    .filter_by(id=self.id)
                    .join(match_, and_(Match.draw == match_.draw,
                                       Match.wn == match_.planning))
                    .one_or_none()
                )
            elif self.draw_id.drawtype == DrawType.ROUND_ROBIN.value:
                self._next_match_id = []  # TODO
            else:
                raise NotImplementedError(f'{self}: unknown drawtype value ({self.draw_id.drawtype})')
        return self._next_match_id

    @hybrid_property
    def entry1_id(self):
        if self._entry1_id is None:  # TODO should be ... == False (because a m2o can be Nene)
            if self.winner == Winner.none.value:  # TODO Use van1 != 0 instead?
                self._entry1_id = None
            else:
                match_ = aliased(Match)
        # help for multiple joins:
        # https://stackoverflow.com/questions/35327701/sql-alchemy-join-multiple-columns-from-same-table
                self._entry1_id = (self.session.query(match_)
                                   .select_from(Match)
                                   .filter_by(id=self.id)
                                   .join(match_, and_(Match.van1 == match_.planning,
                                                      Match.draw == match_.draw))
                                   .join(Entry)
                                   .one_or_none())
        return self._entry1_id

    @hybrid_property
    def entry2_id(self):
        # TODO This has only be done regarding round_robin case!
        if self.winner == Winner.none.value:  # TODO Use van1 != 0 instead?
            return None
        match_ = aliased(Match)
        return (self.session.query(match_)
                .select_from(Match)
                .filter_by(id=self.id)
                .join(match_, and_(Match.draw == match_.draw,
                                   Match.van2 == match_.planning))
                .join(Entry)
                .one_or_none())

    @hybrid_property
    def winner_name(self):
        # TODO Hum, pas top d'utiliser `Winner.none.value`. Y aurait pas mieux?
        return None if self.winner == Winner.none.value else Winner(self.winner).name

    @hybrid_property
    def is_played(self):
        return bool(self.team1set1 | self.team2set1)

    @is_played.expression
    def is_played(cls):
        print('is_played expression')
        return or_(cls.team1set1 > 0, cls.team2set1 > 0)

    @hybrid_property
    def result(self):
        if self.winner == Winner.none.value:
            return None
        set3 = f' {self.team1set3}/{self.team2set3}' if self.team1set3 or self.team2set3 else ''
        return f'{self.team1set1}/{self.team2set1} {self.team1set2}/{self.team2set2}{set3}'

    @property
    def session(self):
        return Session.object_session(self)

    def __repr__(self):
        return f'<Match#{self.id}({self.draw_id}+TODO)>'  # TODO add draw.name + les 2 équipes ('{self.name}')>"

@event.listens_for(Match, 'expire')
def receive_expire(target, attrs):
    # help: https://docs.sqlalchemy.org/en/14/orm/events.html#sqlalchemy.orm.InstanceEvents.expire
    target._entry1_id = None
    target._previous_team_id = False
    target._previous_match_ids = None
    target._next_match_id = False
    target._index_team = None
    target._index_match = None
